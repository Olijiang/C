# 栈

## 1.计算中缀表达式
```
//辅助函数
int isop(char c)
{
	// c 是操作符返回 1， 否则返回 0；
	return (c=='+'||c=='-'||c=='*'||c=='/'||c=='^')?(1):(0);
}

int comop(char op1, char op2)
{
	//如果 op2 操作符比 op1 操作符优先级高或相等，返回 1 ，否则返回 0；
	//if (op2=='(' && op1=='(') return 1;
	if (op2=='(') return 0; //遇到栈中的括号，返回 0 不允许计算
	if (op1=='^') return 0;
	if (op1=='+' || op1=='-') return 1;
	if (op2=='*' || op2=='/' || op2=='^') return 1;
	return 0;
}
int scalcu(int a, int b, char c)
{
	//根据操作符 c 返回 a 对 b 进行 c 操作的结果；
	switch(c)
	{
		case '+':return a+b;
		case '-':return a-b;
		case '*':return a*b;
		case '/':return a/b;
		case '^':return pow(a,b);
		default:return 0;
	}
}
//计算函数
int calcu(char arr[], int n)
{
	char ostack[n/2];	//操作符栈
	int nstack[n/2];	//数字栈
	int otop = -1, ntop = -1;
	int i, a, b, c;
	int mark = 0; //数字进栈 mark 为 1， 操作符进栈 mark 为 0；初始为 0！！
	for (int i = 0; i < n-1; ++i)
	{
		if (arr[i]=='(')
			{
				ostack[++otop] = arr[i];
				continue;
			}
		if (arr[i]==')')
		{	
			//遇到右括号就依次计算左括号前面的操作符
			//完成后弹出左括号
			while(ostack[otop]!='(')
			{
				b = nstack[ntop--];
				a = nstack[ntop--];
				c = scalcu(a,b,ostack[otop--]);
				nstack[++ntop] = c;
			}
			--otop;
			continue;
		}
		if (!isop(arr[i]))
		{
			//字符只有0-9，注意大于10的情况
			if(mark) nstack[ntop] = nstack[ntop]*10 + arr[i]-'0';
			else 
			{
				nstack[++ntop] = arr[i]-'0';
				mark = 1;
				//printf("%d into\n", arr[i]-'0');
			}
		}
		else if (isop(arr[i] && otop==-1))
		{
			 ostack[++otop] = arr[i];
			 mark = 0;
		}
		else
		{
			while(otop!=-1 && comop(arr[i], ostack[otop]))
			{
				//当操作符栈的 栈顶操作符 的优先级大于等于 当前操作符 的优先级时
				//取出栈顶操作符 和 两个数字栈顶部的元素进行运算，结果压回数字栈顶
				if(ostack[otop]=='(') break;
				b = nstack[ntop--];
				a = nstack[ntop--];
				c = scalcu(a,b,ostack[otop--]);
				nstack[++ntop] = c;
			}
			ostack[++otop] = arr[i];
			mark = 0;
		}
		//printf("%d\n", c);
	}
	while(otop!=-1)
	{
		//依次对剩下的操作符进行运算
		b = nstack[ntop--];
		a = nstack[ntop--];
		c = scalcu(a,b,ostack[otop--]);
		nstack[++ntop] = c;
	}
	return nstack[ntop];
}
```
## 2.中缀表达式转后缀表达式
```
void IntoRear(char *In, int n)
{
	//In[]：中缀表达式
	char opstack[n]; //操作符栈
	char Rear[n]; //后缀表达式
	int optop=-1, retop=-1;
	for(int i=0; i<n-1; i++)	//字符串结尾有个空符
		{
		if(In[i]== '(' )   opstack[++optop] = In[i];
		else if(In[i]== ')')
		{
			while(opstack[optop]!='(')
				Rear[++retop] = opstack[optop--];
			optop--;    //跳过当前这个 '('
		}
		else if(!isop(In[i])) Rear[++retop] = In[i];   //数字直接入栈
		else    // 操作符时 
		{
			if(optop == -1) opstack[++optop] = In[i];  //栈空，直接入栈
			else 
			{   // comop(op1, op2), 当 op2 的优先级高于 op1 时返回 1, 否则返回 0；
				// opstack[optop] 栈顶的符号可能为括号，此时直接入操作符栈
				if(opstack[optop]=='(' || comop(opstack[optop], In[i])) opstack[++optop] = In[i];
				else
				{
					Rear[++retop] = opstack[optop--];
					opstack[++optop] = In[i];
				} 
			}
		}
	}
	while(optop!=-1)  Rear[++retop] = opstack[optop--]; //弹出剩余的
	for(int i = 0; i <= retop; i++)  printf("%c ",Rear[i]);
}
```
## 3.括号匹配
```
int KHmatch(char *ch)
{
    int i=0, top = -1;
    char stack[20];
    while (ch[i]!='\0')
    {
        if (ch[i] == '(' || ch[i] == '[')
            stack[++top] = ch[i];
        else
        {
            if (ch[i] == ')' && stack[top] == '(') top--;
            else if (ch[i] == ']' && stack[top] == '[') top--;
            else return 0;
        }
        i++;
    }
    if (top == -1) return 1;
    else return 0;
}
```
---
# 链表
## 1.常规操作
### 1.1节点结构
```
typedef struct Node
{
	int data;
	struct Node *next;
}Node, *LinkList;
```
### 1.2初始化一个链表
```
LinkList Initialist()
{
    //创建并返回一个头节点
    Node *p = (Node *)malloc(sizeof(Node));
	p->next = NULL;
    return p;
}
```
### 1.3添加数据
```
void Add_data(Node **tail, int *data, int n)
{
    //在 tail节点 后 添加数据，data 为数据数组，n 为数据个数
    //此处因为要对tail尾节点做同步修改，使用tail的 地址 操作
	Node *p = NULL;
	for (int i = 0; i < n; ++i)
	{
		p = (Node *)malloc(sizeof(Node));
		p->data = data[i];
		p->next = (*tail)->next;
		(*tail)->next = p;
		(*tail) = p;
	}
}
```
### 1.4删除最小节点
```
int Delete_MinNode(LinkList head)
{   
    Node *p = head->next;
    int min = p->data;
    Node *po = p; //保存最小值节点，初始为第一个
    while (p->next!=NULL)
    {
        if (min > p->next->data)
        {
            min = p->next->data;
            po = p;
            p = p->next;
        }
        else p = p->next;
    }
    //删除节点
    p = po->next;
    po->next = po->next->next;
    free(p);
}
```
### 1.5反转链表
```
Node *Reverse(Node *head)
{   //传入链表头节点，返回反转后的头节点
    Node *p = head->next;
    Node *q;
    while (p->next!=NULL)
    {
        q = p->next;
        p->next = q->next;
        q->next = head->next;
        head->next = q;
    }
    return head;
}
```
### 1.6以字符串形式的数字创建链表
```
Node *Creat(char *s)
{   // s：字符串形式的数字，每个字符一个节点
    int n = strlen(s);
    //printf("%d",n);
    Node *head = (Node *)malloc(sizeof(Node));
    Node *p, *q = head;
    head->d = 0;
    for (int i = 0; i < n; i++)
    {
        p = (Node *)malloc(sizeof(Node));
        p->d = s[i]-'0';
        q->next = p;
        q = p;
    }
    p->next = NULL;
    return head;
}
```
### 1.7逆序打印
```
void reprint(Node *head)
{
	//逆序打印链表
	if(head->next != NULL)
	{
		reprint(head->next);
		printf("%d ", head->next->data);
	}
}
```
## 2.链表实现两个正数减法
```
Node *Minus(Node *LA, Node *LB)
{
    //LA - LB
    LA = Reverse(LA);   //反转数组 ，从底位到高位依次相减
    LB = Reverse(LB);
    int carry=0;    //carry为借位，不够减的时候需要向下一位借位
    int i;
    Node *pla = LA;
    Node *la = LA->next;
    Node *lb = LB->next;
    while (la && lb)
    {
        if (la->d < lb->d)  //如果不够减产生借位
        {
            la->d = la->d - lb->d + 10 - carry;
            carry = 1;
        }
        else
        {
            la->d = la->d - lb->d - carry;
            carry = 0;
        }
        la = la->next;
        lb = lb->next;
        pla = pla->next;
    }
    if (la==NULL) //case1：a 的位数比 b 少的时候， 把剩下的 b 接到 a 后面
    {
        pla->next = lb;
        while (lb!=NULL)
        {
            lb->d = 0 - lb->d + 10 - carry;
            carry = 1;
            lb = lb->next;
        }
    }
    else    //case2：a 的位数比 b 多的时候，
    {
        while (la!=NULL && carry)
        {
            if(la->d==0)  la->d = la->d + 10 - carry;
            else 
            {
                la->d = la->d - carry;
                carry=0;
            }
            la = la->next;
        }
    }
    la = LA->next;
    if (carry==1)  //最后 carry 为 1 的话说明最高位仍产生借位 ，结果为负数
    {
        /*  
        * 比如 123 - 456 = -333，反转后对应位相减结果为 321 - 654 = 766；
        * carry=1，表示最终结果是负数；处理方法是对所有位 9-x；第一位再 +1；
        * 9-7+1=3； 9-6=3； 9-6=3
        * 结果为 -333；
        */
        while (la!=NULL)
        {
            la->d = 9 - la->d;     //用 9 减所有位
            la = la->next;
        }
        LA->next->d++; //个位数修正
    }

    la = LA;
    la = Reverse(la);
    while (la->next->d == 0)    // 将头节点定位到第一个非 0 元素前面,结果为0要特殊考虑
        {
            if(la->next->next!=NULL) la = la->next; 
            else   
            {
                la->next->d = 0;
                break;
            }
        }
    if (carry==1)   // 用头节点标记正负
        la->d = -1;
    else la->d = 1;

    Show(la); 
    //返回结果链表头节点，头节点为-1表示结果为负数，1表示结果非负；
    return la;
}
```
## 3.合并两个有序链表
```
void merge(Node *head_a, Node *head_b)
{
	//把两个有序链表合并为一个有序链表， 头节点不存放数据
	Node *a = head_a->next, *b = head_b->next, *t, *pa = head_a;//a,b为遍历节点，pa是a的前驱节点.
	free(head_b);
	while(a->next != NULL && b != NULL) //当a的下一个节点，b节点都不为空时，将b中的元素插入a中，而b->next!=NULL,会遗留下b的最后一个节点未处理.
	{	//这里若采用a！=NULL作为条件，在循环结束时a为NULL，pa为a链表的最后一个节点，没办法在pa节点之前插入数据.
		if(a->data > b->data) //a>b,把b插入到a前面
		{
			t = b->next;
			b->next = pa->next;
			pa->next = b;
			b = t;
			pa = pa->next;
		}
		else if(a->data < b->data)//a<b，换下一个a
		{
			a = a->next;
			pa = pa->next;
		}
		else //a==b，删除b节点，换下一个b
		{
			t = b;
			b = b->next;
			free(t);
		}
		//执行完毕可能的情况 1.不满足条件 b!= NULL，此时b为NULL，说明b中节点全部插入到a中，合并完成
		// 2.不满足条件 a->next != NULL，此时a->next为NULL，a指向a链表的最后一个节点，b指向剩余b链表的第一个节点。还需要判断b的后续节点和a的最后一个节点的大小关系。
	}
	while(b != NULL) //若不满足条件2,确定b的后续节点和a的最后节点的次序
	{
		if(a->data < b->data)//若a小于b的第一个节点，将b连在a后即可
		{
			a->next = b;
			break;
		}
		else if(a->data > b->data) //若a>b，将b连在a前面，换下一个b
		{
			t = b->next;
			b->next = pa->next;
			pa->next = b;
			b = t;
			pa = pa->next;
		}
		else
		{
			t = b;
			b = b->next;
			free(t);
		}
	}
}
```
## 4.查找倒数第k个
```
int SearchReNum_K(Linklist *head, int k)
{   //打印链表倒数第 k 个元素
    Linklist *p1=head, *p2=head->next;
    for(int i=0; i<k ;i++)  // 将 p1 定位到第 K 个节点
    {
        p1 = p1->next;
        if(p1 == NULL) return 0;    // k 值不合法
    }
    while(p1->next != NULL)     // 遍历到 p1 指向尾节点为止
    {
        p1 = p1->next;
        p2 = p2->next;
    }
    print("%d ", p2->data);
    return 1;
}
```
# 串
## 1.动态字符长度输入
```
char *input()
{
    // 字符串动态长度输入
    // 返回字符指针
    int n = 0, len=10; 
    char c;
    char *ch = (char *)malloc(len);
    char *sh = NULL;
    while((c = getchar())!='\n')
    {
        if (n<len)
            ch[n++] = c;
        else
        {
            len+=10;
            sh = (char *)malloc(len);
            if (sh==NULL) return NULL;
            strcpy(sh,ch);
            ch = sh;
            ch[n++] = c;
        }
    }
    ch[n++] = '\0';
    return ch;
}
```
## 2.KMP
```
//串结构
typedef struct mystr
{
	char *ch;
	int len;	
}mystr;
// 计算getnextval数组
void getnextval(mystr str, int *nextval)
{
	int i=1,j=0;
	nextval[1] = 0;
	while(i<str.len)
	{
		if(j==0||str.ch[i]==str.ch[j])
		{
			++i;++j;
			if (str.ch[i]==str.ch[j]) nextval[i]=nextval[j];
			else nextval[i]=j;
		}
		else j=nextval[j];	//j 指针向前回退
	}
}
//KMP
int KMP(mystr str, mystr substr, int *nextval)
{
	int i=1,j=1;
	while(i<=str.len&&j<=substr.len)
	{
		if (j==0||str.ch[i]==substr.ch[j])
		{
			i++;
			j++;
		}
		else j=nextval[j];

		if (j>substr.len) return i-substr.len;
	}
	return 0;
}
```
## 3.删除指定长度字符
```
void del(mystr *str, int start, int spand)
{
	//start:开始位置    spand:删除长度
	int i=start,j=spand;
	if (i+j > str->len)
	{
		str->len = i-1;
		str->ch[i] = '\0';	
	}
	else
	{
		while(i+j <= str->len)
			str->ch[i++] = str->ch[i+j];
		str->len = str->len-j;
	}

}
```
# 树
# 图
# 排序
# 查找