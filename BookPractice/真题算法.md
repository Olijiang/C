# 2015
### 1.在一个含有n个各不相同元素的无序序列中找出第 k 小的数
- 思路：构建含有 k 个元素的大顶堆，堆中存放序列中最大的 k 个数，遍历完成后，堆顶元素即为第 k 小的数；时间复杂度为 n*logk；
- 步骤：
    - 1.先将序列的前 k 个元素 放入堆中 并调整为大顶堆
    - 2.遍历序列，如果当前元素比堆顶元素小，则放入堆顶，重新调整堆。
- 关键代码：
    - 大顶堆调整（）
        ```
        void AdjustHeap(int *nums, int k, int h)
        {   // k: 要调整的元素位置;   h: 堆的总长度
            int i = k, j = 2*k;
            int temp = nums[i];
            while(j<=h)
            {
                if (j< h) if(nums[j] < nums[j+1]) j++;
                if(temp < nums[j])
                {
                    nums[i] = nums[j];
                    i = j;
                    j = 2*j;
                }
                else break;
            }
            nums[i] = temp;
        }
        ```
---
### 2.以带有双亲指针的二叉树作为二叉树的存储结构，节点类型如下：
```
typedef struct node
{
	int data;
	struct node *lchild, *rchild;
    struct node *parent;
}BinTNode;
```
- 1.就中序序列的不同情况，简要叙述求中序后继的方法
  - (1. 没有右孩子，则 后继节点 是第一个以当前节点所在子树为 左子树 的 节点；
  - (2. 有右孩子，后继节点为右子树中最左的节点。

- 2.编写算法求px所指节点的中序后继节点
  ```
    BinNode *InorderNext(BinNode *px)
    {
        if(px == NULL) retuen NULL;
        BinNode *p = px;
        if(px->rchild != NULL)    //有右孩子时
        {
            p = px->rchild;
            while(p->lchild != NULL) p = p->lchild;
            return p;
        }
        else    // 无右孩子时
        {
            while(p->parent->lchild!=p && p->parent!=NULL) p = p->parent;
            return p->parent;
        }
    }
  ```
- 3.只使用孩子指针而使用双亲指针，编写算法输出从 root 到 px 的路径；
  - 中序遍历，用栈保存经过的路径
    ```
    void PrintPath(BinNode *root, BinNode *px)
    {
        static int path[maxsize]; // maxsize 为已定义的满足长度的常数
        static int top=0;
        static int flag=1;  // 路径找到标志，
        if(root && flag) return;    // flag为0时，不需要再向下遍历，直接返回
        path[top++] = root->data;
        if(root == px)  // 满足条件
        {
            for(int i = 0; i < top; i++) print("%d ",path[i]);
            flag = 0; //flag 置 0 ，截断遍历
        }
        PrintPath(root->lchild);
        PrintPath(root->rchild);
        top--;
    }


    ```
---
# 2016
### 1. 一个带头节点的单链表（Linklist），结构为[data；next],在不改变链表的情况下，查找链表中倒数第 k (正整数) 个位置上的节点； 查找成功，输出节点的data值，返回1； 否则，只返回0；

- 1.思想：设置两个指针，第一个指针先走 k 步（若指针指向空了说明 k 非法），指向不包括头节点在内的第k个节点；此时第二个指针指向头节点的下一个（不包含头节点的第一个节点），然后两个指针同步遍历，当第一个指针的 下一个节点 为空时，第二个指针指向的即为倒数第 k 个元素；

- 2.步骤：同 1；

- 3.算法：
  ```
    int SearchBotten(Linklist *head, int k)
    {
        Linklist *p1=head, *p2=head->next;
        for(int i=0; i<k ;i++)  // 将 p1 定位到第 K 个节点
        {
            p1 = p1->next;
            if(p1 == NULL) return 0;    // k 值不合法
        }
        while(p1->next != NULL)     // 遍历到 p1 指向尾节点为止
        {
            p1 = p1->next;
            p2 = p2->next;
        }
        print("%d ", p2->data);
        return 1;
    }
  ```
### 2. 求带权有向图的最小路径，要求时间复杂度为O((V+E)logK).
  - 做不来
---

# 2017
### 1.关于堆
- 1.存储方式是顺序的还是链接。 顺序
- 2.最大元素和最小元素在说明位置。 最大：堆顶； 最小：叶子节点
- 3.对 n 个元素的建队过程中，最多和最少进行多少次比较；
  - 最少：堆原始有序，从 n/2 开始比较; 若 n 为奇数，共 $\frac{n}{2}*2 = n-1$ 次;若 n 为偶数，最后一个节点只比较一次，共 $\frac{n}{2}*2-1 = n-1$ 次。
  - 最多：假设堆是完全二叉树；树高 $h = log_2n+1$, 从 h-1 层开始比较
    - 讨论最多情况，第$h-1$ 层 每个节点 只需与下一层比较，每个比较2次,共 $2*2^{h-2}*1$
    - 第$h-2$ 层除了和下一层比较之外，下坠后 还需和下层继续比较, 共 $2*2^{h-3}*2$
    - 则第 k 层的元素，最多需要比较的次数为 $2*2^{k-1}*(h-k)$
    - 总次数为$\sum_{k=1}^{h-1}(2*2^{k-1}*(h-k))$ = $2^{h+1}-2(h+1)$

### 2. 两个非空带头节点的增序单链表 ha，hb，求两个链表的交集并将结果存放与 hc 中；要求不能破坏原来的链表。节点结构为：
```
typedef struct Node
{
	int data;
	struct Node *next;
}Node, *LinkList;
```
- 设计一个高效算法并给出时间复杂度
    ```
    Node *Intersection(LinkList ha, LinkList hb)
    {
        LinkList hc = (Node *)malloc(sizeof(Node));
        Node *pa = ha->next, *pb = hb->next, *p, *pre;
        hc->next = NULL;
        while(pa && pb)
        {
            if(pa->data == pb->data)
            {
                p = (Node *)malloc(sizeof(Node)));
                p->data = pa->data;
                p->next = NULL;
                if(hc->next == NULL)    //第一个节点特殊处理
                {
                    hc->next = p;
                    pre = p;
                }
                else    // 后续节点尾插法
                {
                    pre->next = p;
                    pre = p;
                }
            }
            else if(pa->data > pb->data) pb = pb->next;    // 较小的节点向后走
            else pa = pa->next;
        }
        return hc;
    }

    ```
### 3.设计一个算法判断 有向图 中是否有环
- 思路：回溯深度遍历，若一个节点在深度遍历完成之前再次回到了自己，说明存在环路；
与普通深度遍历的区别：常规深度遍历会在访问一个节点后将其标记为已访问，下次遇到时不会访问它；
而回溯深度遍历增加一个标志 标记本轮遍历的节点。若某个节点在一轮遍历中被访问两次，说明有环；
- 代码：
    - 图结构
    ```
    typedef struct ArcNode
    {	//边节点
        int vex; //当前边指向的节点信息
        int cost; //边代价
        struct ArcNode *nextarc;	//下一条边
    }ArcNode;

    typedef struct VNode
    {	//顶点节点
        int vex;	//顶点数据
        ArcNode *firstarc;	// 顶点出来的第一条边
    }VNode;

    typedef struct AGraph
    {
        //邻接表
        VNode Adjlist[maxsize];	//顶点数组
        int v,e; //当前顶点的顶点数和边数
    }AGraph;	
    ```
    - 代码
    ```
    int DetectLoop(AGraph *G, int v)
    {
        static int visit[maxsize];  //标记在一轮遍历中访问过节点
        static int falg = 0;
        ArcNode *p = G->Adjlist.firstarc;
        if(flag) return 1;  //有环
        visit[v] = 1;
        finish[v] = 1;
        while(p!=NULL)
        {
            if(finish[p->vex]==1) flag = 1; // 在一轮遍历中再次访问到访问过的节点，有环
            if(visit[p->vex]==0)
            {
                DetectLoop(p->vex);
                finish[v] = 0;      //退出遍历时释放
            }
            p = p->nextarc;
        }
        return 0;
    } 
    ```
### 3.1 设计一个算法判断 无向图 中是否有环
- 思路: 统计图中 边的个数n 和 节点的个数m，若n>m-1 则说明存在环路
- 代码
    ```
    int DetectLoop(AGraph *G, int v)
    {
        static int visit[maxsize];
        static int edge, vertex;
        ArcNode *p = G->Adjlist.firstarc;
        visit[v] = 1;
        vertex++;
        while(p!=NULL)
        {
            edge++;
            if(visit[p->vex]==0)
                DetectLoop(p->vex);
            p = p->nextarc;
        }
        if(edge/2 > vertex-1) return 1;
        retuen 0;
    } 
    ```
---
# 2018
### 1.有n个顶点的有向图用邻接表表示，写一个算法求顶点 k 的入度
- 遍历邻接表计数求和， 记邻接表为 `Adjlist`
- 代码
    ```
    int InDegree(AGraph *G, int k)
    {
        ArcNode *p;
        int sum=0;
        for(int i=0; i< G->n; i++)
        {
            p = G->Adjlist[i].firstarc;
            while(p != NULL)
            {
                if(p->data == k)
                {
                    sum++;
                    break;
                }
                p = p->next;
            }
        }
        return sum;
    }

    ```

### 2.递归求一颗树中各个节点的平衡因子
- 深度遍历：一个节点的平衡因子等于 左子树高度 减去 右子树高度；
- 节点结构`{ lchild; rchild; bf; data}`
- 代码：
    ```
    int BalanceNum(BinNode *root)
    {
        if(root==NULL) return 0;
        int LD, RD;

        LD = BalanceNum(root->lchlid);
        RD = BalanceNum(root->rchlid);
        root->bf = LD - RD;
        return (LD>RD)?(LD+1):(RD+1); //返回较大的 + 1 作为上一层的树高
    }
    ```
---
# 2019
### 1.深度优先遍历实现有向图的拓扑排序
- 思路:在遍历退出的时候记录节点，可以得到一个逆拓扑排序序列，逆序输出即可得到一个拓扑排序
- 代码：
    ```
    TopoSort(Grapg *G, int v)
    {
        static int topo[maxsize];
        static int top = 0;
        static int visit[maxsize];
        ArcNode *p = G->Adjlist[v].firstarc;
        visit[v] = 1;
        while( p!= NULL)
        {
            if(!visit[p->vex]) 
                TopoSort(G, p->vex);
            p = p->nextarc;
        }
        topo[top++] = v;	//递归退出节点时节点入栈，栈序列为逆拓扑序列

        if(top == maxsize)  //逆序输出
            for(int i=top-1; i>=0; i--) print("%d ", topo[i]);

    }
    ```
### 2.用单链表表示任意长度的整数，每个节点存储一位整数。实现两个正整数的减法操作；
- 代码
    ```
    Node *Minus(Node *LA, Node *LB)
    {
        // LA - LB ， 结果放在 LA 中
        LA = Reverse(LA);   //反转数组 ，从底位到高位依次相减
        LB = Reverse(LB);
        //Show(LA);
        //Show(LB);

        int carry=0;    //carry为借位，不够减的时候需要向下一位借位
        int i;
        Node *pla = LA;
        Node *la = LA->next;
        Node *lb = LB->next;

        while (la && lb)
        {
            if (la->d < lb->d)  //如果不够减产生借位 ， 借位carry 置1
            {
                la->d = la->d - lb->d + 10 - carry;
                carry = 1;
            }
            else    // 够减时，借位carry 置0
            {
                la->d = la->d - lb->d - carry;
                carry = 0;
            }
            la = la->next;
            lb = lb->next;
            pla = pla->next;
        }
        if (la==NULL) //a 的位数比 b 少的时候，用 0 减去 b剩下的数
        {
            pla->next = lb;     // 把 lb 的剩余位数接到 la 后面
            while (lb!=NULL)
            {
                lb->d = 0 - lb->d + 10 - carry;
                carry = 1;
                lb = lb->next;
            }
        }
        //Show(LA);
        la = LA->next;
        if (carry==1)  //最后 carry 为 1 的话说明最高位仍产生借位 ，结果为负数
        {
            /*  比如 123 - 456 = -333，反转后对应位相减结果为 321 - 654 = 766；
                carry=1，表示最终结果是负数 ；处理方法是 是对所有位 9-x；最后 第一位再 +1；
                9-7+1=3； 9-6=3； 9-6=3
                结果为 -333；
            */
            while (la!=NULL)
            {
                la->d = 9 - la->d;     //用 9 减所有位
                la = la->next;
            }
            LA->next->d++; //个位数修正
            printf("-");
        }

        la = LA;
        while (la->next->d == 0)    // 将头节点定位到第一个非 0 元素前面
            la = la->next;
        la = Reverse(la);
        if (carry==1)   // 用头节点标记正负
            la->d = -1;
        else la->d = 1;

        Show(la); 
        //返回结果链表头节点，头节点为-1表示结果为负数，1表示结果非负；
        return la;
    }
    ```
---
# 2020
### 1.二叉树， 从左到右输出第 k 层的节点；
- 思路：层次遍历, 队列（front）进行删除操作，（rear）进行插入操作
- 代码：
    ```
    void K_Floor(BinNode *root, int k)
    {   // 输出第 k 层的节点, 记 root 为第一层
        int queue[maxsize];     // 队列结构 {node, n} ,n标记node所在层
        int le;
        int front=0, rear=0;    // 空时rear==front，不空时front指向第一个，rear指向最后一个的后一个位置
        BinNode *p;
        queue[rear++].node = root; 
        queue[front].n =1;

        while(front!=rear)
        {
            p = queue[front].node;
            le = queue[front].n;
            front = (front+1)%maxsize;
            if(le < k) //到 k-1 层为止, 恰好 k 层可以全部入队
            {
                if(p->lchild != NULL)   // 左孩子入队
                {
                    queue[rear].node = p->lchild;
                    queue[rear].n = ++le;   // 层数+1
                    rear = (rear+1)%maxsize;
                }
                if(p->rchild != NULL)   // 右孩子入队
                {
                    queue[rear].node = p->rchild;
                    queue[rear].n = ++le;   // 层数+1
                    rear = (rear+1)%maxsize;
                }
            }
            if(le = k) print("%d ", p->data);
        }
    }

    ```
### 2.堆排序，删除p位置的元素,重排小根堆；所谓删除，应该是把p位置的数移到数组最后
- 小根堆排序
- 代码
    ```
    void AdjustHeap(int *heap, ,int k, int h)
    {
        int i=k, j=2*k;
        int temp = heap[i]
        while(j<=h)
        {
            if(j< h && heap[j]>heap[j+1]) j++;  //取较小的
            if(temp>heap[j])
            {
                heap[i] = heap[j];
                i = j;
                j = 2*j;
            }
        }
        heap[i] = temp;
    }

    void Delet_p(int *heap, int h, int p)
    {
        heap[n] = heap[p];
        for(int i=n/2; i>0; i++) AdjustHeap(heap, i, h-1);
    }
    ```
---
# 2021
### 1.设带权有向图用邻接矩阵表示，判断图中是否存在从$V_i$到$V_j$的路径，并计算路径长度。要求给出邻阶矩阵的描述。
- 思路：从$V_i$开始深度遍历，如果在遍历中经过了$V_j$节点，则说明存在路径。
- 代码：
    ```
    //邻阶矩阵
    typedef struct Graph
    {
        Adjlist[maxsize][maxsize];  // 邻接矩阵
        int v,e;    // 顶点数和边数
    } Graph;
    ```
    ```
    int MDFS1(Graph *G, int v, int j)
    {   // 若存在路径，则返回长度。若不存在，则返回-1
        static int visit[maxsize];
        static int d=0;   //记录遍历长度
        static int result=-1;	//记录结果长度
        if(result!=-1) return result; 	//截断遍历, result不为-1时，说明已经找到路径
        if(v == j) result = d;
        d++;
        visit[v] = 1;
        for(int k=0; k<maxsize; k++)
            if(G->Adjlist[v][k] && !visit[k])
                MDFS1(G, k, j);
        d--;
        return result;
    }
    ```
### 2.中缀表达式转后缀表达式 可能出现的运算符 `+ - * / ^ ( )`
- 思路：用两个栈，一个栈存放操作符, 一个存放后缀表达式结果
    - 遇到数字直接入结果栈
    - 遇到操作符`（`，直接入操作符栈，遇到 `）`则弹出上一个括号前的全部操作符入结果栈；遇到其他操作符时，若操作符栈为空，直接入栈；若不空，则需和栈顶符比较优先级，栈顶符优先级高或相同时将栈顶符弹出入结果栈，否则之间把现操作符压栈；
    - 代码
        ```
        void IntoRear(char *arr, int n)
        {
            char opstack[n]; //操作符栈
            char restack[n]; //结果栈
            int optop=-1, retop=-1;
            for(int i=0; i<n-1; i++)	//字符串结尾有个空符
                {
                if(arr[i]== '(' )   opstack[++optop] = arr[i];
                else if(arr[i]== ')')
                {
                    while(opstack[optop]!='(')
                        restack[++retop] = opstack[optop--];
                    optop--;    //跳过当前这个 '('
                }
                else if(!isop(arr[i])) restack[++retop] = arr[i];   //数字直接入栈
                else    // 操作符时
                {
                    if(optop == -1) opstack[++optop] = arr[i];  //栈空，直接入栈
                    else 
                    {   // comop(op1, op2), 当 op2 的优先级高于 op1 时返回 1, 否则返回 0；
                        // opstack[optop] 栈顶的符号可能为括号，此时直接入操作符栈
                        if(opstack[optop]=='(' || comop(opstack[optop], arr[i])) opstack[++optop] = arr[i];
                        else
                        {
                            restack[++retop] = opstack[optop--];
                            opstack[++optop] = arr[i];
                        } 
                    }
                }
            }
            while(optop!=-1) restack[++retop] = opstack[optop--]; //弹出剩余的
            for (int i = 0; i <= retop; i++) printf("%c ",restack[i]);
        }
        ```
---